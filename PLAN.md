# Поэтапный план запуска тренировочного бота

Документация-источник: [Концепция и работа бота](docs/kontseptsiya-i-rabota-bota.md), [Архитектура и технические решения](docs/arhitektura-i-tekhnicheskie-resheniya.md), [Правила ИИ и диалога](docs/pravila-ii-i-dialoga.md), [Диалоговая логика и UX чата](docs/dialogovaya-logika-i-ux-chata.md), [Внутренний движок ассистента](docs/vnutrenniy-assistent-dvizhok.md), [Тренировочные программы](docs/trenirovochnye-programmy-i-progressii.md), [Telegram WebApp UI/UX спецификация](docs/telegram-webapp-ui-ux-specifikatsiya.md).

## Шаг 0. Утверждение концепции и рамок
**Цель:** у всей команды единое понимание задачи, ограничения зафиксированы письменно.

1. Провести рабочую сессию по концепции продукта:
   - перечитать целевую персону и сценарии использования ([концепция](docs/kontseptsiya-i-rabota-bota.md));
   - выписать ключевые боли пользователя и ожидаемый результат бота;
   - утвердить «красные линии» — что бот не делает.
2. Сформировать документ Product Requirement Outline:
   - метрики успеха MVP (конверсия в заполнение отчёта, % adherence и т.д.);
   - список KPI по этапам (предзапуск, запуск, 1‑я неделя);
   - минимальный охват функциональности (диалоги, отчёты, адаптации) с ссылкой на разделы документации.
3. Утвердить технологический стек и интеграции:
   - серверная часть (Node.js 18+, Telegraf);
   - Supabase (базы данных, Edge Functions);
   - OpenAI API (модели, квоты, политика использования);
   - внешние сервисы (аналитика, логирование) из [архитектуры](docs/arhitektura-i-tekhnicheskie-resheniya.md).
4. Закрепить ответственность:
   - продуктовый менеджер — дорожная карта, контроль критериев готовности;
   - технический лидер — архитектура, код-ревью;
   - NLU/Prompt инженер — системные промпты, безопасность ИИ;
   - UX дизайнер — копирайтинг, WebApp.
5. Зафиксировать артефакты в общем рабочем пространстве (Notion/Confluence) и указать ссылки в README.

## Шаг 1. Подготовка инфраструктуры
**Цель:** готовые окружения и автоматизация поставки кода.

1. Создание базовой инфраструктуры:
   - Supabase: создать проект, включить Point-in-time recovery, завести бакеты Storage `reports/` и `analytics/`;
   - OpenAI: выпустить API-ключ с префиксом `sk-proj-`, задать квоты и политику ретраев;
   - Платформа деплоя: выбрать Vercel/Render/Railway, создать окружения `dev`, `staging`, `prod`.
2. Настроить Git-репозиторий:
   - создать ветки `main`, `develop`, шаблоны PR и issue;
   - включить обязательные ревью и линтеры в CI;
   - завести каталог `/server`, `/webapp`, `/infra` по [архитектуре](docs/arhitektura-i-tekhnicheskie-resheniya.md).
3. Секреты и переменные окружения:
   - определить `.env.example` для локальной разработки;
   - настроить secret store (Supabase secrets, Vercel environment variables);
   - описать процедуру ротации ключей и ответственных.
4. Мониторинг и логирование:
   - подключить Logflare к Supabase и Telegram Webhook;
   - настроить экспорт логов в Grafana/Prometheus (согласно разделу «Наблюдаемость»);
   - определить критические алерты (ошибка функций, превышение латентности > 2 c).
5. Подготовить чек-лист запуска окружения и проверить доступы у всей команды.

## Шаг 2. Проектирование данных и миграций
**Цель:** единая схема данных, согласованная со всеми сервисами.

1. Подготовка ER-диаграммы:
   - перечитать раздел «Хранение и модели данных» ([архитектура](docs/arhitektura-i-tekhnicheskie-resheniya.md));
   - отрисовать связи `users`, `training_plans`, `plan_versions`, `training_sessions`, `analytics_*`;
   - согласовать поля для версионирования и soft-delete.
2. Реализация миграций:
   - написать SQL-миграции в `/infra/migrations` с версионированием timestamp;
   - задокументировать порядок отката (down-скрипты);
   - обеспечить автоматический прогон миграций при деплое.
3. Настройка RLS и ролей:
   - создать роли `service_role`, `anon`, `bot_service`;
   - определить политики для таблиц с персональными данными (минимум principle of least privilege);
   - добавить тесты политик (использовать Supabase CLI `supabase db test`).
4. Edge Functions и очереди:
   - реализовать `update_plan`, `notify_daily`, `update_settings` по псевдокоду в архитектуре;
   - подключить cron-триггеры для ежедневных уведомлений;
   - задействовать Supabase Queue для отложенных задач.
5. Резервное копирование:
   - включить PITR (point-in-time recovery);
   - настроить ежедневные снапшоты и уведомления об ошибках бэкапа;
   - описать в runbook процесс восстановления.

## Шаг 3. Разработка ядра бота
**Цель:** минимально работоспособный Telegram-бот с основными сценариями.

1. Структура проекта `server/bot`:
   - инициализировать Node.js проект (`pnpm init`), настроить TypeScript, ESLint, Prettier;
   - создать модули `commands/`, `middlewares/`, `services/`, `infrastructure/telegram.ts`;
   - подключить Telegraf, Axios (для Supabase), OpenAI SDK.
2. Обработка команд и событий:
   - реализовать `/start`, `/plan`, `/report`, `/stats`, `/settings`, `/help` согласно [диалоговой логике](docs/dialogovaya-logika-i-ux-chata.md);
   - добавить обработчики callback-кнопок из WebApp, fallback-сценарий на незнакомый ввод;
   - внедрить трекинг событий (логирование в `bot_events`).
3. Middleware и безопасность:
   - аутентификация по Supabase JWT/Session;
   - нормализация текста (удаление PII, проверка токсичности по [Правилам ИИ](docs/pravila-ii-i-dialoga.md));
   - idempotency middleware для повторных апдейтов Telegram.
4. Интеграция с сервисом планирования:
   - создать модуль `services/planner.ts`, который обращается к OpenAI c промптом из [архитектуры](docs/arhitektura-i-tekhnicheskie-resheniya.md);
   - реализовать очередь запросов (BullMQ/Supabase Queue) с ретраями и лимитом параллелизма;
   - сохранять результаты в таблицы `plan_versions` и `plan_version_audit`.
5. Подготовить модульные тесты для команд и мока OpenAI.

## Шаг 4. Настройка NLU и каталога возможностей
**Цель:** бот корректно маршрутизирует свободный ввод пользователя.

1. Каталог возможностей:
   - описать каждую capability (идентификатор, описание, доступные действия) в `docs/capabilities.md`;
   - синхронизировать структуру с таблицей `capabilities` в БД;
   - определить флаги доступности (MVP/experimental).
2. NLU-роутер:
   - реализовать пайплайн из [архитектуры](docs/arhitektura-i-tekhnicheskie-resheniya.md): нормализация → fast-intent → fallback к LLM;
   - обучить лёгкую модель intents (например, `fastText`) на фразах из документации;
   - добавить unit-тесты и dataset regression.
3. Системные промпты и guardrails:
   - обновить промпты для планирования, мотивации, справочных ответов согласно [правилам ИИ](docs/pravila-ii-i-dialoga.md);
   - внедрить фильтры безопасности (safety classifier, ограничение контекста);
   - документировать сценарии эскалации при токсичном контенте.
4. Проверка качества: запустить ручное тестирование 20 сценариев, зафиксировать точность > 90% в README.

## Шаг 5. Планирование тренировок и прогрессия
**Цель:** персонализированные тренировочные планы с возможностью адаптации.

1. Шаблоны тренировок:
   - на базе [логики движка](docs/vnutrenniy-assistent-dvizhok.md) сформировать библиотеку микроциклов (подготовка, прогрессия, разгрузка);
   - оформить JSON-шаблоны с параметрами (уровень, оборудование, ограничения);
   - провести ревью с методистом.
2. Алгоритм адаптаций:
   - реализовать обработку триггеров `travel`, `injury`, `time_crunched`, `recovery` (см. [тренировочные программы](docs/trenirovochnye-programmy-i-progressii.md));
   - добавить сценарии внеплановой сессии и пропуска;
   - документировать fallback при нехватке данных пользователя.
3. Версионирование планов:
   - реализовать сущности `plan_versions`, `plan_version_items`, `plan_version_audit` с автоматическим инкрементом ревизии;
   - хранить диффы между версиями и причину изменения;
   - обеспечить откат к предыдущей версии через Edge Function.
4. Обратная связь и аналитика:
   - реализовать сохранение отчётов `training_sessions`, `exercise_progress`;
   - агрегация KPI (нагрузка, интенсивность, субъективные ощущения);
   - передавать данные в модуль аналитики (шаг 7).
5. Тестирование: прогнать 3 эталонных сценария (новичок, средний уровень, травма) и приложить отчёт.

## Шаг 6. UX-опыт и коммуникации
**Цель:** последовательный голос бренда и удобный интерфейс отчётности.

1. Копирайтинг сообщений:
   - собрать tone-of-voice гайд из [диалоговой логики и UX чата](docs/dialogovaya-logika-i-ux-chata.md);
   - подготовить текст для каждого состояния бота (онбординг, ежедневный отчёт, напоминание);
   - провести лингвистическую проверку (орфография, соответствие правилам).
2. Коммуникационные сценарии:
   - описать ежедневные, еженедельные и milestone-сообщения;
   - заложить условия отправки (если пропуск, если injury, если высокая нагрузка);
   - настроить шаблоны в базе данных/файлах для дальнейшей локализации.
3. Telegram WebApp:
   - реализовать Figma → WebApp (React + Telegram SDK) по [UI/UX спецификации](docs/telegram-webapp-ui-ux-specifikatsiya.md);
   - подключить Supabase для чтения статистики и графиков;
   - обеспечить адаптивность (мобильный/desktop) и поддержку тёмной темы.
4. Медиа и визуализация:
   - подготовить графики прогресса (Chart.js / ECharts) с выгрузкой в Supabase Storage;
   - добавить генерацию изображений для мотивационных сообщений (опционально DALL·E);
   - убедиться, что вес изображений < 500 КБ для быстрой отправки.
5. Провести UX-тестирование на 3 пользователях, собрать замечания и внести правки.

## Шаг 7. Метрики, аналитика и наблюдаемость
**Цель:** прозрачность работы бота и контроль стабильности.

1. Расчёт метрик:
   - реализовать Edge Functions для метрик `adherence_4w`, `progress_level`, `engagement_events`, `ux_nps` (описаны в [архитектуре](docs/arhitektura-i-tekhnicheskie-resheniya.md));
   - добавить расписания на обновление (cron `0 3 * * *` для дневных, `0 4 * * 1` для недельных);
   - сохранять результаты в `analytics_cache`.
2. Отчётность:
   - разработать таблицы `analytics_reports` и шаблоны выгрузок (PDF/PNG);
   - встроить отчёты в WebApp (шаг 6);
   - предусмотреть экспорт CSV по запросу пользователя.
3. Наблюдаемость:
   - собирать события в `observability_events` (тип, payload, user_id);
   - настроить дешборды Grafana (модули: Telegram webhook latency, OpenAI usage, Supabase errors);
   - отправлять критические алерты в Telegram-чат разработчиков.
4. Регулярная проверка: еженедельный обзор метрик и отчёт по инцидентам.

## Шаг 8. Тестирование и запуск
**Цель:** безошибочный релиз и готовность реагировать на инциденты.

1. Тестирование:
   - покрыть unit-тестами команды бота, Edge Functions, алгоритмы планирования;
   - провести интеграционные тесты: Supabase ↔ Bot ↔ OpenAI (использовать staging);
   - автоматизировать регрессионные диалоги (скрипты, записанные сценарии из [диалоговой логики](docs/dialogovaya-logika-i-ux-chata.md)).
2. UX-проверка:
   - прогнать usability-тест с 5 респондентами, зафиксировать метрики SUS;
   - проверить доступность (контраст, озвучка, клавиатура);
   - убедиться в корректности локализации (если есть).
3. Операционная готовность:
   - подготовить runbook инцидентов, определить RTO/RPO;
   - настроить on-call график и каналы связи;
   - проверить процедуру аварийного восстановления (restore из бэкапа).
4. Запуск MVP:
   - провести go/no-go митинг с проверкой критериев готовности из [концепции](docs/kontseptsiya-i-rabota-bota.md);
   - выполнить поэтапный rollout (10 тестовых пользователей → 100 → открытый доступ);
   - включить постзапусковой мониторинг на 48 часов.

## Шаг 9. Пост-MVP развитие
**Цель:** системное развитие продукта после релиза.

1. Сбор обратной связи:
   - настроить сбор отзывов внутри бота (опрос UX NPS);
   - провести интервью с 5 пользователями, выделить повторяющиеся боли;
   - приоритизировать фичи с помощью RICE/ICE.
2. Эксперименты и улучшения:
   - подготовить гипотезы для A/B-тестов (мотивация, напоминания, визуализации);
   - внедрить систему флагов для управляемого выката;
   - обновлять документацию по итогам экспериментов.
3. Долгосрочная карта развития:
   - исследовать интеграции с носимыми устройствами (Garmin, Apple HealthKit);
   - проработать расширенные возможности (питание, сон) — отдельные RFC;
   - заложить процесс обновления модели ИИ (fine-tuning, новые промпты).
