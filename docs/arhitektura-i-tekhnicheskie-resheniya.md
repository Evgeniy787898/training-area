# Архитектура и технические решения

## Обзор платформы
- **Язык и фреймворк бота**: Node.js 18+, библиотека `telegraf` для взаимодействия с Telegram API.
- **Интеграция с ChatGPT**: использование ключа `sk-proj-...` через REST API OpenAI для генерации ответов и планов.
- **Supabase**: база данных PostgreSQL, аутентификация (анонимный ключ) и edge functions для фоновой логики.
- **Хостинг**: Vercel или Render для бота (если требуется постоянное подключение — выделенный сервер/railway). Cron-задачи через Supabase Edge Functions.

## Логическая схема
1. **Telegram Bot**
   - Обработчики команд `/start`, `/plan`, `/report`, `/stats`, `/settings`.
   - Middleware для авторизации твоего единственного Telegram ID.
   - Сервис форматирования сообщений (Markdown, эмодзи, таблицы).
2. **Сервис планирования (ChatGPT)**
   - Модуль генерации тренировок: prompt-инженерия с контекстом цели, доступного оборудования и истории прогресса.
   - Модуль анализа обратной связи: пересчет нагрузки при высоком RPE.
3. **Supabase Backend**
   - Таблицы: `profiles`, `training_sessions`, `metrics`, `achievements`, `weekly_reviews`.
   - Edge Function `update_plan` — анализирует свежие данные, вызывает ChatGPT и обновляет расписание.
   - Edge Function `notify_daily` — пушит план на день в Telegram через webhook.
4. **Система уведомлений**
   - Cron-триггер в Supabase вызывает `notify_daily` каждое утро.
   - При пропуске тренировки Edge Function отправляет мотивационное сообщение.

## Структура проекта
```
root
└─ server/
   ├─ bot/
   │  ├─ index.ts         // точка входа бота
   │  ├─ middleware/
   │  │  └─ auth.ts      // проверка Telegram ID
   │  ├─ services/
   │  │  ├─ planner.ts   // запросы к ChatGPT
   │  │  └─ formatter.ts // сборка сообщений
   │  └─ scenes/         // wizard-сценарии опросов
   ├─ supabase/
   │  ├─ schemas.sql     // миграции таблиц
   │  └─ functions/
   │     ├─ update_plan/index.ts
   │     └─ notify_daily/index.ts
   └─ config/
      └─ env.ts          // работа с ключами и конфигом
```

## Хранение и модели данных
- `profiles`: `id`, `telegram_id`, `goals`, `equipment`, `preferences`, `created_at`.
- `training_sessions`: `id`, `profile_id`, `date`, `session_type`, `exercises`, `rpe`, `notes`.
- `metrics`: `id`, `profile_id`, `metric_type`, `value`, `recorded_at`.
- `achievements`: `id`, `profile_id`, `title`, `description`, `awarded_at`.
- `weekly_reviews`: `id`, `profile_id`, `week_start`, `summary`, `adjustments`.

## NLU и командный роутер
- **Роль**: принимает произвольный текст пользователя, сопоставляет с каталогом поддерживаемых возможностей и трансформирует запрос во внутренние команды.
- **Справочник возможностей (Capability Registry)**: структура данных в Supabase (`capabilities`) с описанием операции, допустимых параметров, ссылок на таблицы/поля и привязанных WebApp экранов.
- **Маппинг**: каждая capability содержит шаблон или intent, набор обязательных и опциональных слотов, а также fallback-текст.
- **Обработка ошибок**: при отсутствии соответствия intent или недостающих параметрах бот возвращает явный ответ «Такой возможности пока нет» либо предлагает доступные альтернативы.
- **Поддержка help/справки**: команда `/help` и быстрые кнопки перечисляют ключевые capabilities, чтобы пользователь видел набор доступных действий даже при наличии NLU.

## Аналитика как изображения
- **Каталог запросов**: предопределённые отчёты (тренды объёма, динамика RPE, прогресс уровней, пропуски тренингов), хранится в таблице `analytics_reports`.
- **Пайплайн**:
  1. Свободный текст → NLU нормализует название отчёта и диапазон дат.
  2. Планировщик параметров заполняет недостающие значения (например, текущая неделя).
  3. Серверная функция строит график (например, через `chart.js` headless) и сохраняет изображение в Supabase Storage.
  4. Бот отправляет изображение в чат.
- **Кэширование**: ключ кэша = `report_type:date_range`. TTL 24 часа, инвалидация при обновлении исходных данных.
- **Отказоустойчивость**: при ошибке генерации картинка заменяется текстовым summary и ссылкой на WebApp.

## Версионирование плана
- **Сущность `plan_versions`**: `id`, `profile_id`, `version`, `created_at`, `summary`, `is_active`.
- **Частичный откат**: таблица `plan_version_items` хранит привязку версий к упражнениям/дням. Операция отката принимает уровень (день/упражнение) и создаёт новую версию с нужным подмножеством данных.
- **Политика доступа**: откат разрешён только владельцу (тебе) и сервисным функциям. Все операции логируются в `plan_version_audit`.
- **Интеграция с ботом**: запрос «откатить понедельник» создаёт команду `PLAN_REVERT` с указанием даты/слота, после чего Edge Function обновляет `is_active` и синхронизирует план.

## Настройки пользователя
- **Модель данных**: поле `notification_time` и `timezone` в `profiles`.
- **Поток изменения**:
  1. Свободный текст («поставь напоминание на 7:30») → NLU нормализует время и валидирует таймзону.
  2. Edge Function `update_settings` обновляет Supabase и логирует событие.
  3. Бот подтверждает изменение и показывает, как отменить/изменить.
- **Правила**: таймзона по умолчанию `Europe/Moscow`. В выходные уведомления отправляются сдвинутыми на +1 час; поддерживаются исключения (например, отпуск) через флаг `notifications_paused`.

## Надёжность и идемпотентность
- **Очередь**: все вызовы ChatGPT и отправки сообщений помещаются в Supabase Edge Queue или аналогичный механизм с ретраями (экспоненциальная задержка, до 3 попыток).
- **Идемпотентность**: ключ операции = комбинация пользователя и действия (`user_id + action + date`). Edge Functions проверяют наличие записей в `operation_log` перед выполнением, предотвращая дублирование уведомлений или двойные обновления плана.
- **Хранение состояния**: результаты успешных операций сохраняются вместе с хэшем payload, что позволяет безопасно повторять запросы после сбоев.

## Наблюдаемость и трассировка
- **Структурированный лог**: события `user_action`, `ai_decision`, `plan_change`, `analytics_rendered`, `error` записываются в Supabase `observability_events`.
- **Trace ID**: для каждого пользовательского запроса генерируется `trace_id`, который прокидывается через NLU, Edge Functions и Telegram ответы.
- **Метрики**: latency NLU, время генерации отчётов, количество откатов плана, доля ошибок.
- **Карта ошибок**: категории `external_api_failure`, `validation_error`, `timeout`, `rate_limit`. Каждой категории соответствует реакция: повтор, фолбэк на текст, уведомление пользователя.

## Поток данных
1. Ты запускаешь `/start` — бот создает запись в `profiles` (если нет) и запускает опрос.
2. Ответы сохраняются, формируется начальный план через ChatGPT, результат пишется в `training_sessions` на ближайшие 14 дней.
3. Каждое утро Edge Function `notify_daily` читает план на день, форматирует сообщение и отправляет через Telegram.
4. После тренировки ты отправляешь отчет `/report`, бот сохраняет RPE, заметки, обновляет статистику и триггерит `update_plan` при необходимости.
5. По воскресеньям бот собирает данные недели, формирует обзор и отправляет в Telegram.

## Безопасность и секреты
- Переменные окружения: `OPENAI_API_KEY`, `TELEGRAM_BOT_TOKEN`, `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_KEY`.
- Хранить ключи в `.env` и не коммитить в репозиторий.
- Доступ к боту ограничен проверкой Telegram ID.
- Запросы к OpenAI идут через HTTPS, Supabase подключение — по SSL.

## Мониторинг и журналы
- Логи бота отправляются в Supabase Logflare или Papertrail.
- Edge Functions пишут структурированные логи (время вызова, результат, ошибки).
- Telegram webhook настроен на ручной перезапуск при ошибках.

## План внедрения
1. Настроить репозиторий с описанной структурой.
2. Создать Supabase проект и применить `schemas.sql`.
3. Подготовить ChatGPT промпты и протестировать ответы.
4. Реализовать бота и edge functions.
5. Провести интеграционное тестирование на тестовом чате.
6. Перенести бота на постоянный хостинг и включить ежедневные задачи.
