# Внутренний движок тренера

Документ описывает локальный движок, который формирует ответы тренера, строит планы и анализирует отчёты, не обращаясь к внешним AI-сервисам. Поведенческие сценарии и безопасность диалогов описаны в отдельном документе [«Правила поведения и интентов тренера»](pravila-trenera-i-dialoga.md).

## Архитектура

```
server/services/internalAssistantEngine.js
 ├─ interpretCommand()         // нормализация интента и извлечение слотов
 ├─ generateTrainerReply()     // структурированные подсказки тренера
 ├─ generateGeneralReply()     // свободные ответы и приветствия
 ├─ generateTrainingPlan()     // подготовка недельного плана
 ├─ analyzeTrainingReport()    // анализ отчёта о тренировки
 ├─ buildMotivationMessage()   // мотивационные сообщения
 ├─ buildPlanHint()            // краткие подсказки по плану
 ├─ buildFeedbackMessage()     // шаблон обратной связи после отчёта
 ├─ buildNoteSaveReply()       // сохранение заметок пользователя
 ├─ buildTriggersHelpReply()   // справка по ключевым командам/триггерам
 ├─ getEngineCatalog()         // описание доступных движков для WebApp
 └─ resolveEngine()            // выбор движка на основе настроек профиля
```

Поддерживающие модули:

- `services/conversation.js` — объединяет движок с fallback-логикой (статический план, быстрые ответы).
- `services/planner.js` — экспортирует API для бота и WebApp (`generateTrainingPlan`, `analyzeTrainingReport`).
- `services/aiCommandRouter.js` — приводит запросы к структуре `interpretCommand()`.
- `infrastructure/supabase.js` — слой доступа к данным (профиль, сессии, шаблоны `ai_templates`).
- Supabase Edge Function `update_plan` использует те же принципы, чтобы строить планы на стороне базы.

## Источники данных

1. **Supabase**: таблицы `profiles`, `training_sessions`, `metrics`, `plan_versions`, `dialog_state`.
2. **Контекст выполнения**: история сообщений (до 10 штук), флаги восстановления, streak, последняя тренировка.
3. **Шаблоны ответов**: таблица `ai_templates`, где хранится текст шаблонов для категорий `greeting`, `motivation`, `plan_hint`, `feedback`.
4. **Журнал заметок**: таблица `assistant_notes` хранит сохранённые пользователем записи (текст, теги, источник).
5. **Fallback-план**: генерация через `buildDefaultWeekPlan()` на случай отсутствия актуального расписания в БД.

## Интерпретация команд

`interpretCommand()` приводит текст к normalized-интенту и заполняет служебные поля:

- Преобразует исходный интент из `nlu.detectIntent()` в snake-case (`plan_today`, `report_start`, `remind_later`, …).
- Добавляет `candidateIntents` — упорядоченный список совпадений с вероятностями. Используется для подсказок пользователю.
- Извлекает `slots`: `reminder`, `preferred_shift_days`, `preferred_day`, а при команде «сохрани» — `note` (текст заметки и теги).
- Выставляет `needsClarification`, если данных не хватает (например, время напоминания не распознано).
- Распознаёт приветствия и благодарности (`GREETING_REGEX`, `GRATITUDE_REGEX`), чтобы корректно отвечать в свободном режиме.

Результат содержит: `intent`, `confidence`, `entities`, `slots`, `followUp`, `history` и `profileId` (если профайл известен).

## Формат ответов тренера

`generateTrainerReply()` формирует структурированные блоки:

```
<резюме>
**Цель:** …
**Разминка:** …
**Основная часть:** …
**Заминка:** …
**Следующий шаг:** …
```

- Для `plan_today` и `plan_week` используется ближайшая сессия из плана пользователя или fallback-план. Содержимое адаптируется под streak и статус последней тренировки.
- `report_start` возвращает пошаговую инструкцию по отчёту.
- `schedule_reschedule` и `remind_later` используют заполненные слоты для подтверждения действий либо запрашивают уточнение.
- `stats_show` собирает статистику (adherence, streak, статус последней тренировки).
- `recovery_mode` включает инструкцию по восстановлению; `motivation` использует шаблоны из `ai_templates`.
- `note_save` сохраняет заметку в `assistant_notes`, показывает превью и подсказывает работу с тегами.
- `triggers_help` выдаёт справку по ключевым командам и примерам формулировок.
- Неизвестные тренерские запросы сводятся к генерик-подсказке с напоминанием цели пользователя.

## Диалоговый режим

`generateGeneralReply()` отвечает, когда не требуется строгий тренерский формат:

- Приветствия и общие вопросы используют шаблоны `greeting`, обогащённые текущей статистикой (streak, completion rate).
- Мотивационные запросы берут шаблоны `motivation` и добавляют CTA из метаданных.
- Подсказки по плану (`plan_today`, `plan_week`) возвращают короткие выдержки из `plan_hint`.
- Fallback-сценарий уточняет задачу и предлагает помощь с планом/отчётом/восстановлением.

## Сохранение заметок

- `buildNoteSaveReply()` анализирует команды «Сохрани…», извлекает текст и хэштеги, сохраняет запись в `assistant_notes` и увеличивает счётчик заметок в `dialog_states`.
- Ответ возвращает превью заметки, перечисляет теги и напоминает, как запросить заметки через WebApp или API.
- Все события сохраняются в `observability_events` (`category = assistant_note_saved`), что позволяет отслеживать использование функции памяти.

## Справка по триггерам

- `buildTriggersHelpReply()` формирует динамический список часто используемых команд (план, отчёт, напоминание, заметки).
- Используется как в NLU-интенте `triggers_help`, так и в быстрой справке (`localResponder`).
- Выходит в ответ на запросы «справка по триггерам», «что ты можешь», а также доступна через WebApp API `POST /v1/assistant/reply`.

## Генерация планов

`generateTrainingPlan()`:

1. Определяет частоту тренировок (из профиля или дефолт `4`).
2. Генерирует недельный план через `buildDefaultWeekPlan()` и формирует текстовое резюме.
3. Прикладывает историю последних сессий, если она передана в контекст.
4. Возвращает объект вида `{ rawText, structured }`, где `structured.plan` готов для сохранения в `plan_versions`.

## Анализ отчётов

`analyzeTrainingReport()` агрегирует данные тренировки:

- Считает количество выполненных, частичных и пропущенных упражнений, оценивает общий completion rate.
- Анализирует RPE и заметки на предмет усталости или лёгкости и подсказывает, куда сместить акценты.
- Формирует рекомендации (`suggestions`): `advance`, `maintain`, `regress`, `recovery`.
- Возвращает `feedback` — готовый текст для отправки пользователю, и числовые индикаторы для логирования.

## Мотивация и подсказки

- `buildMotivationMessage()` использует контекст (`streak`, `completion`) и шаблоны `motivation`, добавляя персонализированные комментарии.
- `buildPlanHint()` формирует краткое напоминание на день или неделю.
- `buildFeedbackMessage()` берёт шаблоны `feedback` и заполняет их фактическим значением completion и RPE.

## Расширение движка

1. **Новые интенты** — добавить паттерны в `services/nlu.js`, затем обработку в `interpretCommand()` и соответствующий блок в `generateTrainerReply()` или `generateGeneralReply()`.
2. **Новые шаблоны** — пополнить таблицу `ai_templates` (например, дополнительные поздравления или сценарии для отпуска), убедиться, что указаны `category` и `tag`.
3. **Дополнительные данные** — расширить `loadContext()` и подчитать новые поля (сон, HRV, режимы) с использованием Supabase.
4. **Тональность** — обновить логику генерации приветствий/мотивации, если появляются новые сценарии (например, «подготовка к соревнованиям»).
5. **Память и заметки** — доработать `buildNoteSaveReply()` (категории, атачменты), расширить API `/v1/assistant/notes`, добавлять напоминания поверх сохранённых заметок.

## Логирование и кеши

- Fallback-планы кешируются в `dialog_state` с ключом `ui_cached_plan` и TTL до конца недели.
- События настроек и прогресса записываются через `db.logEvent` (категории `preferences_updated`, `exercise_progress_updated`).
- Метрики завершения тренировок фиксируются командой `/report` через `db.recordMetric`.

Документ следует обновлять при любом изменении архитектуры движка или формате ответов, чтобы все участники команды опирались на единый источник правды.
